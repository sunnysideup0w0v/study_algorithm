# RedBlack Tree

## 정의

RedBlack 트리는 AVL 트리와 마찬가지로 데이터의 삽입/제거가 일어날 때 스스로 균형을 맞추는 자가균형 트리로, 각 노드는 붉은색(red), 검은색(color)을 가지고 있다고 하여 붙여진 이름이다.

### 다른 트리와의 차이점

**높이**
AVL 트리, 혹은 다른 이진 트리에서의 높이는 단 하나뿐이지만 Red-Black트리에서는 "Black Height" 라는 높이라는 개념이 하나 더 있다.
Black Height는 루트 노드에서부터 터미널 노드(NIL)까지 경로에 존재하는 모든 검은색 노드의 수를 의미합니다.

**균형의 엄격함(AVL 트리와의 비교)**
동일한 자가 균형 트리인 AVL 트리는 균형에 매우 엄격한 반면, Red-Black 트리는 균형에 조금 더 관대하다.
트리의 균형을 맞출 때 Red-Black 트리는 AVL 트리에 비해 회전이 조금 더 적게 일어나 데이터의 삽입/제거 속도가 조금 더 빠른 반면,
데이터를 조회하는 경우에는 AVL 트리의 속도가 더 빠르다는 차이점을 가지고 있다.

**삽입(AVL 트리와의 비교)**
Red-Black 트리도 AVL 트리와 마찬가지로 데이터의 사입/제거가 이루어질 때 회전을 통해 균형을 맞춘다.
단, Red-Black 트리는 회전 외에 reColoring 이라는 단계를 추가적으로 진행하여 Red-Black 트리의 규칙을 위반하지 않을 수 있도록 각 노드가 가지는 색을 다시 지정해준다.(삽입 하는 모든 새로운 노드는 빨간색을 가지고 있다.)

## Red-Black 트리의 규칙

1. 모든 노드는 빨간색이나 검은색 두 가지 색 중 하나를 가지고 있다.
2. 루트 노드는 항상 검은색이다.
3. 모든 터미널 노드(NIL)는 검은색이다.
4. 연속해서 빨간색 노드가 올 수 없다.
5. 루트노드에서 터미널 노드인 NIL 노드까지 모든 경로에는 같은 수의 검은색 노드가 있어야 한다. => 데이터 삽입/제거 시 rebalanceAfterInsertion 함수를 호출해 균형을 잡아준다.

### rebalanceAfterInsertion 함수가 처리해야 하는 것

**1. 새로운 노드가 루트노드인 경우**
새로 삽입한 노드는 무조건 빨간색이지만, 루트 노드는 항상 검은색이어야 하기 때문에(규칙 1) 검은색으로 바꿔준다.

**2. 부모노드와 삼촌노드가 빨간색인 경우**
삼촌 노드란 부모 노드의 형제 노드를 의미하는 것으로, 새로 삽입된 노드는 무조건 빨간색이기 때문에 부모/삼촌 노드는 검은색으로 + 할아버지 노드는 빨간색으로 칠해주어야 한다.
단, 할아버지의 부모 노드, 즉 증조 할아버지 노드가 빨간색이라면 4번 규칙을 어기게 되어 할아버지 노드를 대상으로 규칙을 위반하지 않을 때까지 재귀적으로 올라가며 색을 다시 지정해주어야 한다.

**3. 부모 노드는 빨간색, 삼촌 노드는 검은색, 새로운 노드는 안쪽 손자인 경우**
안쪽 손자 = 부모 노드의 자식 노드, 즉 할아버지 노드의 손자 노드가 왼쪽으로 가지를 내려 삽입된 경우를 의미한다. 할아버지 노드를 기준으로 부모 노드, 삽입된 노드의 모양이 삼각형을 이루게 된다.
AVL 트리에서 RL 회전을 진행했던 경우와 동일한 형태.
4번 규칙을 위반하게 되므로 균형을 다시 맞춰주어야 하는데, 부모 노드를 삽입된 노드의 반대 방향, 즉 오른쪽으로 회전시키고 -> 부모 노드가 회전한 방향 반대 방향(왼쪽)으로 할아버지 노드를 회전시켜준다음 -> recoloring을 진행하여 새로 삽입된 노드는 검은색, 할아버지 노드는 빨간색으로 바꿔준다.

**4. 부모 노드는 빨간색, 삼촌 노드는 검은색, 새로운 노드는 바깥쪽 손자인 경우**
바깥쪽 손자 = 할아버지 노드를 기준으로 부모 노드, 손자 노드가 일직선으로 뻗어져있는 경우. AVL 트리에서 LL 회전이 필요했던 경우와 마찬가지이다.
할아버지 노드를 삽입된 노드의 반대 방향으로 회전시키고(왼쪽으로) -> 부모 노드를 검은색으로, 할아버지 노드를 빨간색으로 바꿔준다.

## Red-Black 트리에서의 데이터 삭제

### 데이터 제거의 규칙

1. 제거할 노드의 두 개의 자식 노드가 모두 NIL 노드인 경우, 타겟 노드를 제거한 후 부모 노드의 자식 노드에 NIL 노드를 연결해준다.
2. 제거할 노드의 두 개의 자식 노드 중 한 개가 NIL 노드인 경우, 제거할 노드를 삭제하고 그의 자식 노드가 제거할 노드의 자리를 대신할 수 있도록 연결해준다.
3. 제거할 노드의 자식에서 NIL 노드가 한 개도 없는 경우, 자식 노드 중 한 개가 삭제하고자 하는 노드의 자리를 대체해야 한다.

### 제거할 노드의 자식에 NIL 노드가 한 개도 없는 경우

1. 왼쪽 서브트리의 노드 중 가장 큰 값, 혹은 오른쪽 서브트리의 노드 중 가장 작은 값이 타겟 노드(제거하려는 노드)의 자리를 대체하도록 해야 한다.
2. Red 노드가 삭제되는 경우, Black Height가 변경되거나 Red 노드가 연속적으로 올 일은 없기 때문에 Red-Black 트리의 규칙을 위반할 가능성이 적거나 없다.
3. Black 노드가 삭제되는 경우, Black Height가 변경되고 Red 노드가 연속적으로 배치 될 가능성이 높기 때문에 삭제 후 규칙성을 위반하는 노드/트리는 없는지 확인이 필요하다.

### 노드 삭제 후 균형을 다시 잡을 때 처리해야 할 경우들

1. 형제 노드가 빨간색인 경우
   a. 제거 대상 노드를 삭제하고
   b. 부모 노드의 색상을 Red로, 형제 노드의 색상을 Black으로 recoloring을 진행한다.
   c. recoloring을 진행하고 나면 Black Height의 변경과 동시에 규칙(모든 경로는 동일한 수의 Black 노드를 가지고 있어야 한다)을 위반하게 되므로
   d. 상황에 맞게 부모 노드를 회전시켜주는 등 균형을 다시 맞추고 recoloring을 진행하는 과정을 거쳐야 한다.
2. 형제 노드와 형제 노드의 두 자식노드가 모두 검은색이고 부모노드는 빨간색인 경우
   a. 대상 노드를 제거하고
   b. Black Height가 달라짐에 따라 형제 노드를 붉은 색으로, 부모 노드를 검은색으로 recoloring을 진행한다.
3. 형제 노드와 형제 노드의 두 자식 노드, 부모 노드가 모두 검은색인 경우
   a. 제거할 타겟 노드를 제거한다.
   b. Black Height가 달라지므로 타겟 노드의 형제 노드를 붉은색으로 Recoloring 진행
   c. 루트 노드와 타겟 노드 사이에 가상의 노드가 있고, 해당 노드를 삭제하고 부모 노드가 대체 노드가 되었다고 가정
   d. 루트 노드를 검은색으로, 형제 노드를 붉은색으로 recoloring을 진행한다. -> 다시 정리가 필요함
4. 형제 노드가 검은색이고 형제의 두 자식노드 중 하나라도 빨간색 노드가 있고 "바깥쪽 조카 노드"가 검은색인 경우
   a. 제거할 노드를 제거한다 -> 부모 노드의 왼쪽 자식 노드는 NIL노드가 됨
   b. 제거한 노드의 안쪽 조카 노드는 검은색으로, 형제 노드는 붉은색으로 recoloring을 진행
   c. 형제 노드를 제거한 노드의 반대 방향으로 회전
   d. 새로운 형제 노드의 색을 부모 노드의 색으로, 부모 노드와 바깥쪽 조카 노드의 색은 그 반대 색으로 recoloring을 진행
   e. 부모 노드를 삭제한 노드의 방향으로 회전
5. 형제 노드가 검은색이고 형제의 두 자식 노드 중 하나라도 빨간색 노드가 있고 "바깥쪽 조카 노드"가 빨간색인 경우
   a. 제거할 타겟 노드 삭제
   b. 형제 노드의 색을 부모 노드의 색으로 변경해준다.
   c. 부모 노드와 바깥쪽 노드의 색을 변경해준다.
   d. 부모 노드를 제거된 노드의 방향으로 회전
